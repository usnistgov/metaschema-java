<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnnotationGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data/Object Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind.codegen</a> &gt; <span class="el_source">AnnotationGenerator.java</span></div><h1>AnnotationGenerator.java</h1><pre class="source lang-java linenums">/*
 * Portions of this software was developed by employees of the National Institute
 * of Standards and Technology (NIST), an agency of the Federal Government and is
 * being made available as a public service. Pursuant to title 17 United States
 * Code Section 105, works of NIST employees are not subject to copyright
 * protection in the United States. This software may be subject to foreign
 * copyright. Permission in the United States and in foreign countries, to the
 * extent that NIST may hold copyright, to use, copy, modify, create derivative
 * works, and distribute this software and its documentation without fee is hereby
 * granted on a non-exclusive basis, provided that this notice and disclaimer
 * of warranty appears in all copies.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS' WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND FREEDOM FROM
 * INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL CONFORM TO THE
 * SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE ERROR FREE.  IN NO EVENT
 * SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT,
 * INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM,
 * OR IN ANY WAY CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT, OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY PERSONS OR
 * PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED FROM, OR AROSE OUT
 * OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.
 */

package gov.nist.secauto.metaschema.databind.codegen;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.AnnotationSpec.Builder;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.TypeSpec;

import gov.nist.secauto.metaschema.core.datatype.IDataTypeAdapter;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupLine;
import gov.nist.secauto.metaschema.core.datatype.markup.MarkupMultiline;
import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.ISequence;
import gov.nist.secauto.metaschema.core.metapath.MetapathExpression;
import gov.nist.secauto.metaschema.core.metapath.StaticContext;
import gov.nist.secauto.metaschema.core.metapath.item.node.IAssemblyNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.IDefinitionNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.INodeItemFactory;
import gov.nist.secauto.metaschema.core.model.IAssemblyDefinition;
import gov.nist.secauto.metaschema.core.model.IFlagContainer;
import gov.nist.secauto.metaschema.core.model.INamedInstance;
import gov.nist.secauto.metaschema.core.model.INamedModelInstance;
import gov.nist.secauto.metaschema.core.model.IValuedDefinition;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValue;
import gov.nist.secauto.metaschema.core.model.constraint.IAllowedValuesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.ICardinalityConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IExpectConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IIndexHasKeyConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IKeyField;
import gov.nist.secauto.metaschema.core.model.constraint.IMatchesConstraint;
import gov.nist.secauto.metaschema.core.model.constraint.IUniqueConstraint;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValue;
import gov.nist.secauto.metaschema.databind.model.annotations.AllowedValues;
import gov.nist.secauto.metaschema.databind.model.annotations.AssemblyConstraints;
import gov.nist.secauto.metaschema.databind.model.annotations.Expect;
import gov.nist.secauto.metaschema.databind.model.annotations.HasCardinality;
import gov.nist.secauto.metaschema.databind.model.annotations.Index;
import gov.nist.secauto.metaschema.databind.model.annotations.IndexHasKey;
import gov.nist.secauto.metaschema.databind.model.annotations.IsUnique;
import gov.nist.secauto.metaschema.databind.model.annotations.KeyField;
import gov.nist.secauto.metaschema.databind.model.annotations.Matches;
import gov.nist.secauto.metaschema.databind.model.annotations.ValueConstraints;

import org.apache.logging.log4j.LogBuilder;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.lang.reflect.Method;
import java.util.List;
import java.util.regex.Pattern;

import edu.umd.cs.findbugs.annotations.NonNull;

/**
 * A variety of utility functions for creating Module annotations.
 */
@SuppressWarnings({
    &quot;PMD.GodClass&quot; // utility class
})
final class AnnotationGenerator {
<span class="fc" id="L89">  private static final Logger LOGGER = LogManager.getLogger(AnnotationGenerator.class);</span>

  private AnnotationGenerator() {
    // disable construction
  }

  public static Object getDefaultValue(Class&lt;?&gt; annotation, String member) {
    Method method;
    try {
<span class="nc" id="L98">      method = annotation.getDeclaredMethod(member);</span>
<span class="nc" id="L99">    } catch (NoSuchMethodException ex) {</span>
<span class="nc" id="L100">      throw new IllegalArgumentException(ex);</span>
<span class="nc" id="L101">    }</span>
    Object retval;
    try {
<span class="nc" id="L104">      retval = method.getDefaultValue();</span>
<span class="nc" id="L105">    } catch (TypeNotPresentException ex) {</span>
<span class="nc" id="L106">      retval = null; // NOPMD readability</span>
<span class="nc" id="L107">    }</span>
<span class="nc" id="L108">    return retval;</span>
  }

  private static void buildConstraint(Class&lt;?&gt; annotationType, AnnotationSpec.Builder annotation,
      IConstraint constraint) {
<span class="nc" id="L113">    String id = constraint.getId();</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">    if (id != null) {</span>
<span class="nc" id="L115">      annotation.addMember(&quot;id&quot;, &quot;$S&quot;, id);</span>
    }

<span class="nc" id="L118">    String formalName = constraint.getFormalName();</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">    if (formalName != null) {</span>
<span class="nc" id="L120">      annotation.addMember(&quot;formalName&quot;, &quot;$S&quot;, formalName);</span>
    }

<span class="nc" id="L123">    MarkupLine description = constraint.getDescription();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">    if (description != null) {</span>
<span class="nc" id="L125">      annotation.addMember(&quot;description&quot;, &quot;$S&quot;, description.toMarkdown());</span>
    }

<span class="nc" id="L128">    annotation.addMember(&quot;level&quot;, &quot;$T.$L&quot;, IConstraint.Level.class, constraint.getLevel());</span>

<span class="nc" id="L130">    MetapathExpression target = constraint.getTarget();</span>
<span class="nc" id="L131">    String path = target.getPath();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">    if (!path.equals(getDefaultValue(annotationType, &quot;target&quot;))) {</span>
<span class="nc" id="L133">      annotation.addMember(&quot;target&quot;, &quot;$S&quot;, path);</span>
    }
<span class="nc" id="L135">  }</span>

  public static void buildValueConstraints(
      @NonNull FieldSpec.Builder builder,
      @NonNull IValuedDefinition definition) {
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">    if (!definition.getConstraints().isEmpty()) {</span>
<span class="nc" id="L141">      AnnotationSpec.Builder valueConstraintsAnnotation = AnnotationSpec.builder(ValueConstraints.class);</span>

<span class="nc" id="L143">      applyAllowedValuesConstraints(valueConstraintsAnnotation, definition.getAllowedValuesConstraints());</span>
<span class="nc" id="L144">      applyIndexHasKeyConstraints(valueConstraintsAnnotation, definition.getIndexHasKeyConstraints());</span>
<span class="nc" id="L145">      applyMatchesConstraints(valueConstraintsAnnotation, definition.getMatchesConstraints());</span>
<span class="nc" id="L146">      applyExpectConstraints(valueConstraintsAnnotation, definition.getExpectConstraints());</span>

<span class="nc" id="L148">      builder.addAnnotation(valueConstraintsAnnotation.build());</span>
    }
<span class="fc" id="L150">  }</span>

  public static void buildValueConstraints(
      @NonNull TypeSpec.Builder builder,
      @NonNull IFlagContainer definition) {

<span class="fc" id="L156">    List&lt;? extends IAllowedValuesConstraint&gt; allowedValues = definition.getAllowedValuesConstraints();</span>
<span class="fc" id="L157">    List&lt;? extends IIndexHasKeyConstraint&gt; indexHasKey = definition.getIndexHasKeyConstraints();</span>
<span class="fc" id="L158">    List&lt;? extends IMatchesConstraint&gt; matches = definition.getMatchesConstraints();</span>
<span class="fc" id="L159">    List&lt;? extends IExpectConstraint&gt; expects = definition.getExpectConstraints();</span>

<span class="pc bpc" id="L161" title="4 of 8 branches missed.">    if (!allowedValues.isEmpty() || !indexHasKey.isEmpty() || !matches.isEmpty() || !expects.isEmpty()) {</span>
<span class="nc" id="L162">      AnnotationSpec.Builder annotation = AnnotationSpec.builder(ValueConstraints.class);</span>

<span class="nc" id="L164">      applyAllowedValuesConstraints(annotation, allowedValues);</span>
<span class="nc" id="L165">      applyIndexHasKeyConstraints(annotation, indexHasKey);</span>
<span class="nc" id="L166">      applyMatchesConstraints(annotation, matches);</span>
<span class="nc" id="L167">      applyExpectConstraints(annotation, expects);</span>

<span class="nc" id="L169">      builder.addAnnotation(annotation.build());</span>
    }
<span class="fc" id="L171">  }</span>

  public static void buildAssemblyConstraints(
      @NonNull TypeSpec.Builder builder,
      @NonNull IAssemblyDefinition definition) {

<span class="fc" id="L177">    List&lt;? extends IIndexConstraint&gt; index = definition.getIndexConstraints();</span>
<span class="fc" id="L178">    List&lt;? extends IUniqueConstraint&gt; unique = definition.getUniqueConstraints();</span>
<span class="fc" id="L179">    List&lt;? extends ICardinalityConstraint&gt; cardinality = definition.getHasCardinalityConstraints();</span>

<span class="pc bpc" id="L181" title="3 of 6 branches missed.">    if (!index.isEmpty() || !unique.isEmpty() || !cardinality.isEmpty()) {</span>
<span class="nc" id="L182">      AnnotationSpec.Builder annotation = ObjectUtils.notNull(AnnotationSpec.builder(AssemblyConstraints.class));</span>

<span class="nc" id="L184">      applyIndexConstraints(annotation, index);</span>
<span class="nc" id="L185">      applyUniqueConstraints(annotation, unique);</span>
<span class="nc" id="L186">      applyHasCardinalityConstraints(definition, annotation, cardinality);</span>

<span class="nc" id="L188">      builder.addAnnotation(annotation.build());</span>
    }
<span class="fc" id="L190">  }</span>

  private static void applyAllowedValuesConstraints(AnnotationSpec.Builder annotation,
      List&lt;? extends IAllowedValuesConstraint&gt; constraints) {
<span class="nc bnc" id="L194" title="All 2 branches missed.">    for (IAllowedValuesConstraint constraint : constraints) {</span>
<span class="nc" id="L195">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(AllowedValues.class);</span>
<span class="nc" id="L196">      buildConstraint(AllowedValues.class, constraintAnnotation, constraint);</span>

<span class="nc" id="L198">      boolean isAllowedOther = constraint.isAllowedOther();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">      if (!Boolean.valueOf(isAllowedOther).equals(getDefaultValue(AllowedValues.class, &quot;allowOthers&quot;))) {</span>
<span class="nc" id="L200">        constraintAnnotation.addMember(&quot;allowOthers&quot;, &quot;$L&quot;, isAllowedOther);</span>
      }

<span class="nc bnc" id="L203" title="All 2 branches missed.">      for (IAllowedValue value : constraint.getAllowedValues().values()) {</span>
<span class="nc" id="L204">        AnnotationSpec.Builder valueAnnotation = AnnotationSpec.builder(AllowedValue.class);</span>

<span class="nc" id="L206">        valueAnnotation.addMember(&quot;value&quot;, &quot;$S&quot;, value.getValue());</span>
<span class="nc" id="L207">        valueAnnotation.addMember(&quot;description&quot;, &quot;$S&quot;, value.getDescription().toMarkdown());</span>

<span class="nc" id="L209">        constraintAnnotation.addMember(&quot;values&quot;, &quot;$L&quot;, valueAnnotation.build());</span>
<span class="nc" id="L210">      }</span>

<span class="nc" id="L212">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L214">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }
<span class="nc" id="L216">      annotation.addMember(&quot;allowedValues&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="nc" id="L217">    }</span>
<span class="nc" id="L218">  }</span>

  private static void applyIndexHasKeyConstraints(AnnotationSpec.Builder annotation,
      List&lt;? extends IIndexHasKeyConstraint&gt; constraints) {
<span class="nc bnc" id="L222" title="All 2 branches missed.">    for (IIndexHasKeyConstraint constraint : constraints) {</span>
<span class="nc" id="L223">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(IndexHasKey.class);</span>
<span class="nc" id="L224">      buildConstraint(IndexHasKey.class, constraintAnnotation, constraint);</span>

<span class="nc" id="L226">      constraintAnnotation.addMember(&quot;indexName&quot;, &quot;$S&quot;, constraint.getIndexName());</span>

<span class="nc" id="L228">      buildKeyFields(constraintAnnotation, constraint.getKeyFields());</span>

<span class="nc" id="L230">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L232">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="nc" id="L235">      annotation.addMember(&quot;indexHasKey&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="nc" id="L236">    }</span>
<span class="nc" id="L237">  }</span>

  private static void buildKeyFields(@NonNull Builder constraintAnnotation,
      @NonNull List&lt;? extends IKeyField&gt; keyFields) {
<span class="nc bnc" id="L241" title="All 2 branches missed.">    for (IKeyField key : keyFields) {</span>
<span class="nc" id="L242">      AnnotationSpec.Builder keyAnnotation = AnnotationSpec.builder(KeyField.class);</span>

<span class="nc" id="L244">      MetapathExpression target = key.getTarget();</span>
<span class="nc" id="L245">      String path = target.getPath();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">      if (!path.equals(getDefaultValue(KeyField.class, &quot;target&quot;))) {</span>
<span class="nc" id="L247">        keyAnnotation.addMember(&quot;target&quot;, &quot;$S&quot;, path);</span>
      }

<span class="nc" id="L250">      Pattern pattern = key.getPattern();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">      if (pattern != null) {</span>
<span class="nc" id="L252">        keyAnnotation.addMember(&quot;pattern&quot;, &quot;$S&quot;, pattern.pattern());</span>
      }

<span class="nc" id="L255">      MarkupMultiline remarks = key.getRemarks();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L257">        keyAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="nc" id="L260">      constraintAnnotation.addMember(&quot;keyFields&quot;, &quot;$L&quot;, keyAnnotation.build());</span>
<span class="nc" id="L261">    }</span>
<span class="nc" id="L262">  }</span>

  private static void applyMatchesConstraints(AnnotationSpec.Builder annotation,
      List&lt;? extends IMatchesConstraint&gt; constraints) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">    for (IMatchesConstraint constraint : constraints) {</span>
<span class="nc" id="L267">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(Matches.class);</span>
<span class="nc" id="L268">      buildConstraint(Matches.class, constraintAnnotation, constraint);</span>

<span class="nc" id="L270">      Pattern pattern = constraint.getPattern();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (pattern != null) {</span>
<span class="nc" id="L272">        constraintAnnotation.addMember(&quot;pattern&quot;, &quot;$S&quot;, pattern.pattern());</span>
      }

<span class="nc" id="L275">      IDataTypeAdapter&lt;?&gt; dataType = constraint.getDataType();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">      if (dataType != null) {</span>
<span class="nc" id="L277">        constraintAnnotation.addMember(&quot;typeAdapter&quot;, &quot;$T.class&quot;, dataType.getClass());</span>
      }

<span class="nc" id="L280">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L282">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }
<span class="nc" id="L284">      annotation.addMember(&quot;matches&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="nc" id="L285">    }</span>
<span class="nc" id="L286">  }</span>

  private static void applyExpectConstraints(AnnotationSpec.Builder annotation,
      List&lt;? extends IExpectConstraint&gt; constraints) {
<span class="nc bnc" id="L290" title="All 2 branches missed.">    for (IExpectConstraint constraint : constraints) {</span>
<span class="nc" id="L291">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(Expect.class);</span>

<span class="nc" id="L293">      buildConstraint(Expect.class, constraintAnnotation, constraint);</span>

<span class="nc" id="L295">      MetapathExpression test = constraint.getTest();</span>
<span class="nc" id="L296">      constraintAnnotation.addMember(&quot;test&quot;, &quot;$S&quot;, test.getPath());</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">      if (constraint.getMessage() != null) {</span>
<span class="nc" id="L299">        constraintAnnotation.addMember(&quot;message&quot;, &quot;$S&quot;, constraint.getMessage());</span>
      }

<span class="nc" id="L302">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L304">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="nc" id="L307">      annotation.addMember(&quot;expect&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="nc" id="L308">    }</span>
<span class="nc" id="L309">  }</span>

  private static void applyIndexConstraints(AnnotationSpec.Builder annotation,
      List&lt;? extends IIndexConstraint&gt; constraints) {
<span class="nc bnc" id="L313" title="All 2 branches missed.">    for (IIndexConstraint constraint : constraints) {</span>
<span class="nc" id="L314">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(Index.class);</span>

<span class="nc" id="L316">      buildConstraint(Index.class, constraintAnnotation, constraint);</span>

<span class="nc" id="L318">      constraintAnnotation.addMember(&quot;name&quot;, &quot;$S&quot;, constraint.getName());</span>

<span class="nc" id="L320">      buildKeyFields(constraintAnnotation, constraint.getKeyFields());</span>

<span class="nc" id="L322">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L324">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="nc" id="L327">      annotation.addMember(&quot;index&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="nc" id="L328">    }</span>
<span class="nc" id="L329">  }</span>

  private static void applyUniqueConstraints(AnnotationSpec.Builder annotation,
      List&lt;? extends IUniqueConstraint&gt; constraints) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">    for (IUniqueConstraint constraint : constraints) {</span>
<span class="nc" id="L334">      AnnotationSpec.Builder constraintAnnotation = ObjectUtils.notNull(AnnotationSpec.builder(IsUnique.class));</span>

<span class="nc" id="L336">      buildConstraint(IsUnique.class, constraintAnnotation, constraint);</span>

<span class="nc" id="L338">      buildKeyFields(constraintAnnotation, constraint.getKeyFields());</span>

<span class="nc" id="L340">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L342">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }

<span class="nc" id="L345">      annotation.addMember(&quot;isUnique&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>
<span class="nc" id="L346">    }</span>
<span class="nc" id="L347">  }</span>

  @SuppressWarnings({
      &quot;PMD.GuardLogStatement&quot; // guarded in outer calls
  })
  private static void checkCardinalities(
      @NonNull IAssemblyDefinition definition,
      @NonNull ICardinalityConstraint constraint,
      @NonNull ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; instanceSet,
      @NonNull LogBuilder logBuilder) {

<span class="nc" id="L358">    LogBuilder warn = LOGGER.atWarn();</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">    for (IDefinitionNodeItem&lt;?, ?&gt; item : instanceSet.asList()) {</span>
<span class="nc" id="L360">      INamedInstance instance = item.getInstance();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">      if (instance instanceof INamedModelInstance) {</span>
<span class="nc" id="L362">        INamedModelInstance modelInstance = (INamedModelInstance) instance;</span>

<span class="nc" id="L364">        checkMinOccurs(definition, constraint, modelInstance, logBuilder);</span>
<span class="nc" id="L365">        checkMaxOccurs(definition, constraint, modelInstance, logBuilder);</span>
<span class="nc" id="L366">      } else {</span>
<span class="nc" id="L367">        warn.log(String.format(</span>
            &quot;Definition '%s' has min-occurs=%d cardinality constraint targeting '%s' that is not a model instance&quot;,
<span class="nc" id="L369">            definition.getName(), constraint.getMinOccurs(), constraint.getTarget().getPath()));</span>
      }
<span class="nc" id="L371">    }</span>
<span class="nc" id="L372">  }</span>

  @SuppressWarnings({
      &quot;PMD.GuardLogStatement&quot; // guarded in outer calls
  })
  private static void checkMinOccurs(
      @NonNull IAssemblyDefinition definition,
      @NonNull ICardinalityConstraint constraint,
      @NonNull INamedModelInstance modelInstance,
      @NonNull LogBuilder logBuilder) {
<span class="nc" id="L382">    Integer minOccurs = constraint.getMinOccurs();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">    if (minOccurs != null) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">      if (minOccurs == modelInstance.getMinOccurs()) {</span>
<span class="nc" id="L385">        logBuilder.log(String.format(</span>
            &quot;Definition '%s' has min-occurs=%d cardinality constraint targeting '%s' that is redundant with a&quot;
                + &quot; targeted instance named '%s' that requires min-occurs=%d&quot;,
<span class="nc" id="L388">            definition.getName(), minOccurs, constraint.getTarget().getPath(),</span>
<span class="nc" id="L389">            modelInstance.getName(),</span>
<span class="nc" id="L390">            modelInstance.getMinOccurs()));</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">      } else if (minOccurs &lt; modelInstance.getMinOccurs()) {</span>
<span class="nc" id="L392">        logBuilder.log(String.format(</span>
            &quot;Definition '%s' has min-occurs=%d cardinality constraint targeting '%s' that conflicts with a&quot;
                + &quot; targeted instance named '%s' that requires min-occurs=%d&quot;,
<span class="nc" id="L395">            definition.getName(), minOccurs, constraint.getTarget().getPath(),</span>
<span class="nc" id="L396">            modelInstance.getName(),</span>
<span class="nc" id="L397">            modelInstance.getMinOccurs()));</span>
      }
    }
<span class="nc" id="L400">  }</span>

  @SuppressWarnings({
      &quot;PMD.GuardLogStatement&quot; // guarded in outer calls
  })
  private static void checkMaxOccurs(
      @NonNull IAssemblyDefinition definition,
      @NonNull ICardinalityConstraint constraint,
      @NonNull INamedModelInstance modelInstance,
      @NonNull LogBuilder logBuilder) {
<span class="nc" id="L410">    Integer maxOccurs = constraint.getMaxOccurs();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">    if (maxOccurs != null) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">      if (maxOccurs == modelInstance.getMaxOccurs()) {</span>
<span class="nc" id="L413">        logBuilder.log(String.format(</span>
            &quot;Definition '%s' has max-occurs=%d cardinality constraint targeting '%s' that is redundant with a&quot;
                + &quot; targeted instance named '%s' that requires max-occurs=%d&quot;,
<span class="nc" id="L416">            definition.getName(), maxOccurs, constraint.getTarget().getPath(),</span>
<span class="nc" id="L417">            modelInstance.getName(),</span>
<span class="nc" id="L418">            modelInstance.getMaxOccurs()));</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">      } else if (maxOccurs &lt; modelInstance.getMaxOccurs()) {</span>
<span class="nc" id="L420">        logBuilder.log(String.format(</span>
            &quot;Definition '%s' has max-occurs=%d cardinality constraint targeting '%s' that conflicts with a&quot;
                + &quot; targeted instance named '%s' that requires max-occurs=%d&quot;,
<span class="nc" id="L423">            definition.getName(), maxOccurs, constraint.getTarget().getPath(),</span>
<span class="nc" id="L424">            modelInstance.getName(),</span>
<span class="nc" id="L425">            modelInstance.getMaxOccurs()));</span>
      }
    }
<span class="nc" id="L428">  }</span>

  private static void applyHasCardinalityConstraints(
      @NonNull IAssemblyDefinition definition,
      @NonNull AnnotationSpec.Builder annotation,
      @NonNull List&lt;? extends ICardinalityConstraint&gt; constraints) {

<span class="nc" id="L435">    DynamicContext dynamicContext = StaticContext.newInstance().newDynamicContext();</span>
<span class="nc" id="L436">    dynamicContext.disablePredicateEvaluation();</span>

<span class="nc bnc" id="L438" title="All 2 branches missed.">    for (ICardinalityConstraint constraint : constraints) {</span>

      IAssemblyNodeItem definitionNodeItem
<span class="nc" id="L441">          = INodeItemFactory.instance().newAssemblyNodeItem(definition);</span>

<span class="nc" id="L443">      ISequence&lt;? extends IDefinitionNodeItem&lt;?, ?&gt;&gt; instanceSet</span>
<span class="nc" id="L444">          = constraint.matchTargets(definitionNodeItem, dynamicContext);</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">      if (LOGGER.isWarnEnabled()) {</span>
<span class="nc" id="L447">        checkCardinalities(definition, constraint, instanceSet, ObjectUtils.notNull(LOGGER.atWarn()));</span>
      }

<span class="nc" id="L450">      AnnotationSpec.Builder constraintAnnotation = AnnotationSpec.builder(HasCardinality.class);</span>

<span class="nc" id="L452">      buildConstraint(HasCardinality.class, constraintAnnotation, constraint);</span>

<span class="nc" id="L454">      Integer minOccurs = constraint.getMinOccurs();</span>
<span class="nc bnc" id="L455" title="All 4 branches missed.">      if (minOccurs != null &amp;&amp; !minOccurs.equals(getDefaultValue(HasCardinality.class, &quot;minOccurs&quot;))) {</span>
<span class="nc" id="L456">        constraintAnnotation.addMember(&quot;minOccurs&quot;, &quot;$L&quot;, minOccurs);</span>
      }

<span class="nc" id="L459">      Integer maxOccurs = constraint.getMaxOccurs();</span>
<span class="nc bnc" id="L460" title="All 4 branches missed.">      if (maxOccurs != null &amp;&amp; !maxOccurs.equals(getDefaultValue(HasCardinality.class, &quot;maxOccurs&quot;))) {</span>
<span class="nc" id="L461">        constraintAnnotation.addMember(&quot;maxOccurs&quot;, &quot;$L&quot;, maxOccurs);</span>
      }

<span class="nc" id="L464">      annotation.addMember(&quot;hasCardinality&quot;, &quot;$L&quot;, constraintAnnotation.build());</span>

<span class="nc" id="L466">      MarkupMultiline remarks = constraint.getRemarks();</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">      if (remarks != null) {</span>
<span class="nc" id="L468">        constraintAnnotation.addMember(&quot;remarks&quot;, &quot;$S&quot;, remarks.toMarkdown());</span>
      }
<span class="nc" id="L470">    }</span>
<span class="nc" id="L471">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>