<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IBindingContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Java Data/Object Binding and Code Generation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.databind</a> &gt; <span class="el_source">IBindingContext.java</span></div><h1>IBindingContext.java</h1><pre class="source lang-java linenums">/*
 * Portions of this software was developed by employees of the National Institute
 * of Standards and Technology (NIST), an agency of the Federal Government and is
 * being made available as a public service. Pursuant to title 17 United States
 * Code Section 105, works of NIST employees are not subject to copyright
 * protection in the United States. This software may be subject to foreign
 * copyright. Permission in the United States and in foreign countries, to the
 * extent that NIST may hold copyright, to use, copy, modify, create derivative
 * works, and distribute this software and its documentation without fee is hereby
 * granted on a non-exclusive basis, provided that this notice and disclaimer
 * of warranty appears in all copies.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS' WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND FREEDOM FROM
 * INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL CONFORM TO THE
 * SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE ERROR FREE.  IN NO EVENT
 * SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT,
 * INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM,
 * OR IN ANY WAY CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT, OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY PERSONS OR
 * PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED FROM, OR AROSE OUT
 * OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.
 */

package gov.nist.secauto.metaschema.databind;

import gov.nist.secauto.metaschema.core.datatype.IDataTypeAdapter;
import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.StaticContext;
import gov.nist.secauto.metaschema.core.metapath.item.node.IDocumentNodeItem;
import gov.nist.secauto.metaschema.core.metapath.item.node.INodeItem;
import gov.nist.secauto.metaschema.core.model.IAssemblyDefinition;
import gov.nist.secauto.metaschema.core.model.IFlagContainer;
import gov.nist.secauto.metaschema.core.model.IModule;
import gov.nist.secauto.metaschema.core.model.constraint.DefaultConstraintValidator;
import gov.nist.secauto.metaschema.core.model.constraint.FindingCollectingConstraintValidationHandler;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraintValidationHandler;
import gov.nist.secauto.metaschema.core.model.constraint.IConstraintValidator;
import gov.nist.secauto.metaschema.core.model.validation.AggregateValidationResult;
import gov.nist.secauto.metaschema.core.model.validation.IValidationResult;
import gov.nist.secauto.metaschema.core.model.validation.JsonSchemaContentValidator;
import gov.nist.secauto.metaschema.core.model.validation.XmlSchemaContentValidator;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.databind.codegen.ModuleCompilerHelper;
import gov.nist.secauto.metaschema.databind.io.BindingException;
import gov.nist.secauto.metaschema.databind.io.DeserializationFeature;
import gov.nist.secauto.metaschema.databind.io.Format;
import gov.nist.secauto.metaschema.databind.io.IBoundLoader;
import gov.nist.secauto.metaschema.databind.io.IDeserializer;
import gov.nist.secauto.metaschema.databind.io.ISerializer;
import gov.nist.secauto.metaschema.databind.io.yaml.YamlOperations;
import gov.nist.secauto.metaschema.databind.model.IAssemblyClassBinding;
import gov.nist.secauto.metaschema.databind.model.IClassBinding;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaAssembly;
import gov.nist.secauto.metaschema.databind.model.annotations.MetaschemaField;

import org.json.JSONObject;
import org.xml.sax.SAXException;

import java.io.IOException;
import java.math.BigInteger;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.ZonedDateTime;
import java.util.List;

import javax.xml.namespace.QName;
import javax.xml.transform.Source;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * Provides information supporting a binding between a set of Module models and
 * corresponding Java classes.
 */
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">public interface IBindingContext extends IModuleLoaderStrategy {</span>

  /**
   * Get the singleton {@link IBindingContext} instance, which can be used to load
   * information that binds a model to a set of Java classes.
   *
   * @return a new binding context
   */
  @NonNull
  static IBindingContext instance() {
<span class="fc" id="L89">    return DefaultBindingContext.instance();</span>
  }

  /**
   * Register a matcher used to identify a bound class by the content's root name.
   *
   * @param matcher
   *          the matcher implementation
   * @return this instance
   */
  @NonNull
  IBindingContext registerBindingMatcher(@NonNull IBindingMatcher matcher);

  /**
   * Determine the bound class for the provided XML {@link QName}.
   *
   * @param rootQName
   *          the root XML element's QName
   * @return the bound class or {@code null} if not recognized
   * @see IBindingContext#registerBindingMatcher(IBindingMatcher)
   */
  @Nullable
  Class&lt;?&gt; getBoundClassForXmlQName(@NonNull QName rootQName);

  /**
   * Determine the bound class for the provided JSON/YAML property/item name using
   * any registered matchers.
   *
   * @param rootName
   *          the JSON/YAML property/item name
   * @return the bound class or {@code null} if not recognized
   * @see IBindingContext#registerBindingMatcher(IBindingMatcher)
   */
  @Nullable
  Class&lt;?&gt; getBoundClassForJsonName(@NonNull String rootName);

  /**
   * Get's the {@link IDataTypeAdapter} associated with the specified Java class,
   * which is used to read and write XML, JSON, and YAML data to and from
   * instances of that class. Thus, this adapter supports a direct binding between
   * the Java class and structured data in one of the supported formats. Adapters
   * are used to support bindings for simple data objects (e.g., {@link String},
   * {@link BigInteger}, {@link ZonedDateTime}, etc).
   *
   * @param &lt;TYPE&gt;
   *          the class type of the adapter
   * @param clazz
   *          the Java {@link Class} for the bound type
   * @return the adapter instance or {@code null} if the provided class is not
   *         bound
   */
  @Nullable
  &lt;TYPE extends IDataTypeAdapter&lt;?&gt;&gt; TYPE getJavaTypeAdapterInstance(@NonNull Class&lt;TYPE&gt; clazz);

  /**
   * Generate, compile, and load a set of generated Module annotated Java classes
   * based on the provided Module {@code module}.
   *
   * @param module
   *          the Module module to generate classes for
   * @param compilePath
   *          the path to the directory to generate classes in
   * @return this instance
   * @throws IOException
   *           if an error occurred while generating or loading the classes
   */
  @SuppressWarnings(&quot;PMD.UseProperClassLoader&quot;) // false positive
  @NonNull
  default IBindingContext registerModule(
      @NonNull IModule module,
      @NonNull Path compilePath) throws IOException {
<span class="fc" id="L160">    Files.createDirectories(compilePath);</span>

<span class="fc" id="L162">    ClassLoader classLoader = ModuleCompilerHelper.newClassLoader(</span>
        compilePath,
<span class="fc" id="L164">        ObjectUtils.notNull(Thread.currentThread().getContextClassLoader()));</span>

<span class="fc" id="L166">    ModuleCompilerHelper.compileMetaschema(module, compilePath).getGlobalDefinitionClassesAsStream()</span>
<span class="fc" id="L167">        .filter(definitionInfo -&gt; {</span>
<span class="fc" id="L168">          boolean retval = false;</span>
<span class="fc" id="L169">          IFlagContainer definition = definitionInfo.getDefinition();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">          if (definition instanceof IAssemblyDefinition) {</span>
<span class="fc" id="L171">            IAssemblyDefinition assembly = (IAssemblyDefinition) definition;</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (assembly.isRoot()) {</span>
<span class="fc" id="L173">              retval = true;</span>
            }
          }
<span class="fc" id="L176">          return retval;</span>
        })
<span class="fc" id="L178">        .map(</span>
            generatedClass -&gt; {
              try {
<span class="fc" id="L181">                @SuppressWarnings(&quot;unchecked&quot;) Class&lt;IAssemblyClassBinding&gt; clazz</span>
<span class="fc" id="L182">                    = ObjectUtils.notNull((Class&lt;IAssemblyClassBinding&gt;) classLoader</span>
<span class="fc" id="L183">                        .loadClass(generatedClass.getClassName().reflectionName()));</span>

<span class="fc" id="L185">                IAssemblyDefinition definition = (IAssemblyDefinition) generatedClass.getDefinition();</span>
<span class="fc" id="L186">                return new DynamicBindingMatcher(</span>
                    definition,
                    clazz);
<span class="nc" id="L189">              } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L190">                throw new IllegalStateException(ex);</span>
              }
            })
<span class="fc" id="L193">        .forEachOrdered(</span>
<span class="fc" id="L194">            matcher -&gt; registerBindingMatcher(</span>
<span class="fc" id="L195">                ObjectUtils.notNull(</span>
                    matcher)));
<span class="fc" id="L197">    return this;</span>
  }

  /**
   * Gets a data {@link ISerializer} which can be used to write Java instance data
   * for the provided class to the requested format. The provided class must be a
   * bound Java class with a {@link MetaschemaAssembly} or {@link MetaschemaField}
   * annotation for which a {@link IClassBinding} exists.
   *
   * @param &lt;CLASS&gt;
   *          the Java type this deserializer can write data from
   * @param format
   *          the format to serialize into
   * @param clazz
   *          the Java data type to serialize
   * @return the serializer instance
   * @throws NullPointerException
   *           if any of the provided arguments, except the configuration, are
   *           {@code null}
   * @throws IllegalArgumentException
   *           if the provided class is not bound to a Module assembly or field
   * @throws UnsupportedOperationException
   *           if the requested format is not supported by the implementation
   * @see #getClassBinding(Class)
   */
  @NonNull
  &lt;CLASS&gt; ISerializer&lt;CLASS&gt; newSerializer(@NonNull Format format, @NonNull Class&lt;CLASS&gt; clazz);

  /**
   * Gets a data {@link IDeserializer} which can be used to read Java instance
   * data for the provided class from the requested format. The provided class
   * must be a bound Java class with a {@link MetaschemaAssembly} or
   * {@link MetaschemaField} annotation for which a {@link IClassBinding} exists.
   *
   * @param &lt;CLASS&gt;
   *          the Java type this deserializer can read data into
   * @param format
   *          the format to serialize into
   * @param clazz
   *          the Java data type to serialize
   * @return the deserializer instance
   * @throws NullPointerException
   *           if any of the provided arguments, except the configuration, are
   *           {@code null}
   * @throws IllegalArgumentException
   *           if the provided class is not bound to a Module assembly or field
   * @throws UnsupportedOperationException
   *           if the requested format is not supported by the implementation
   * @see #getClassBinding(Class)
   */
  @NonNull
  &lt;CLASS&gt; IDeserializer&lt;CLASS&gt; newDeserializer(@NonNull Format format, @NonNull Class&lt;CLASS&gt; clazz);

  /**
   * Get a new {@link IBoundLoader} instance.
   *
   * @return the instance
   */
  @NonNull
  IBoundLoader newBoundLoader();

  /**
   * Create a deep copy of the provided bound object.
   *
   * @param &lt;CLASS&gt;
   *          the bound object type
   * @param other
   *          the object to copy
   * @param parentInstance
   *          the object's parent or {@code null}
   * @return a deep copy of the provided object
   * @throws BindingException
   *           if an error occurred copying content between java instances
   * @throws NullPointerException
   *           if the provided object is {@code null}
   * @throws IllegalArgumentException
   *           if the provided class is not bound to a Module assembly or field
   */
  @NonNull
  &lt;CLASS&gt; CLASS copyBoundObject(@NonNull CLASS other, Object parentInstance) throws BindingException;

  /**
   * Get a new single use constraint validator.
   *
   * @param handler
   *          the validation handler to use to process the validation results
   *
   * @return the validator
   */
  default IConstraintValidator newValidator(@NonNull IConstraintValidationHandler handler) {
<span class="nc" id="L287">    IBoundLoader loader = newBoundLoader();</span>
<span class="nc" id="L288">    loader.disableFeature(DeserializationFeature.DESERIALIZE_VALIDATE_CONSTRAINTS);</span>

<span class="nc" id="L290">    DynamicContext context = StaticContext.newInstance().newDynamicContext();</span>
<span class="nc" id="L291">    context.setDocumentLoader(loader);</span>

<span class="nc" id="L293">    return new DefaultConstraintValidator(context, handler);</span>
  }

  /**
   * Perform constraint validation on the provided bound object represented as an
   * {@link INodeItem}.
   *
   * @param nodeItem
   *          the node item to validate
   * @return the validation result
   * @throws IllegalArgumentException
   *           if the provided class is not bound to a Module assembly or field
   */
  default IValidationResult validate(@NonNull INodeItem nodeItem) {
<span class="nc" id="L307">    FindingCollectingConstraintValidationHandler handler = new FindingCollectingConstraintValidationHandler();</span>
<span class="nc" id="L308">    IConstraintValidator validator = newValidator(handler);</span>
<span class="nc" id="L309">    validator.validate(nodeItem);</span>
<span class="nc" id="L310">    validator.finalizeValidation();</span>
<span class="nc" id="L311">    return handler;</span>
  }

  /**
   * Load and perform schema and constraint validation on the target. The
   * constraint validation will only be performed if the schema validation passes.
   *
   * @param target
   *          the target to validate
   * @param asFormat
   *          the schema format to use to validate the target
   * @param schemaProvider
   *          provides callbacks to get the appropriate schemas
   * @return the validation result
   * @throws IOException
   *           if an error occurred while reading the target
   * @throws SAXException
   *           if an error occurred when parsing the target as XML
   */
  default IValidationResult validate(
      @NonNull Path target,
      @NonNull Format asFormat,
      @NonNull IValidationSchemaProvider schemaProvider) throws IOException, SAXException {
    IValidationResult retval;
<span class="nc bnc" id="L335" title="All 4 branches missed.">    switch (asFormat) {</span>
    case JSON:
<span class="nc" id="L337">      retval = new JsonSchemaContentValidator(schemaProvider.getJsonSchema()).validate(target);</span>
<span class="nc" id="L338">      break;</span>
    case XML:
<span class="nc" id="L340">      List&lt;Source&gt; schemaSources = schemaProvider.getXmlSchemas();</span>
<span class="nc" id="L341">      retval = new XmlSchemaContentValidator(schemaSources).validate(target);</span>
<span class="nc" id="L342">      break;</span>
    case YAML:
<span class="nc" id="L344">      JSONObject json = YamlOperations.yamlToJson(YamlOperations.parseYaml(target));</span>
<span class="nc bnc" id="L345" title="All 4 branches missed.">      assert json != null;</span>
<span class="nc" id="L346">      retval = new JsonSchemaContentValidator(schemaProvider.getJsonSchema())</span>
<span class="nc" id="L347">          .validate(json, ObjectUtils.notNull(target.toUri()));</span>
<span class="nc" id="L348">      break;</span>
    default:
<span class="nc" id="L350">      throw new UnsupportedOperationException(&quot;Unsupported format: &quot; + asFormat.name());</span>
    }

<span class="nc bnc" id="L353" title="All 2 branches missed.">    if (retval.isPassing()) {</span>
<span class="nc" id="L354">      IValidationResult constraintValidationResult = validateWithConstraints(target);</span>
<span class="nc" id="L355">      retval = AggregateValidationResult.aggregate(retval, constraintValidationResult);</span>
    }
<span class="nc" id="L357">    return retval;</span>
  }

  /**
   * Load and validate the provided {@code target} using the associated Module
   * module constraints.
   *
   * @param target
   *          the file to load and validate
   * @return the validation results
   * @throws IOException
   *           if an error occurred while loading the document
   */
  default IValidationResult validateWithConstraints(@NonNull Path target) throws IOException {
<span class="nc" id="L371">    IBoundLoader loader = newBoundLoader();</span>
<span class="nc" id="L372">    loader.disableFeature(DeserializationFeature.DESERIALIZE_VALIDATE_CONSTRAINTS);</span>

<span class="nc" id="L374">    DynamicContext dynamicContext = StaticContext.newInstance().newDynamicContext();</span>
<span class="nc" id="L375">    dynamicContext.setDocumentLoader(loader);</span>
<span class="nc" id="L376">    IDocumentNodeItem nodeItem = loader.loadAsNodeItem(target);</span>

<span class="nc" id="L378">    return validate(nodeItem);</span>
  }

  interface IValidationSchemaProvider {
    /**
     * Get a JSON schema to use for content validation.
     *
     * @return the JSON schema
     * @throws IOException
     *           if an error occurred while loading the schema
     */
    @NonNull
    JSONObject getJsonSchema() throws IOException;

    /**
     * Get a XML schema to use for content validation.
     *
     * @return the XML schema sources
     * @throws IOException
     *           if an error occurred while loading the schema
     */
    @NonNull
    List&lt;Source&gt; getXmlSchemas() throws IOException;
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>