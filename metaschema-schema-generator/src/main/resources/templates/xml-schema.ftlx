<#ftl ns_prefixes={"xs":"http://www.w3.org/2001/XMLSchema"}>
<#-- schema-specific data types -->
<#assign schemaTypes = ['date-with-timezone','dateTime-with-timezone','email','hostname','ip-v4-address','ip-v6-address','markup-line','markup-multiline','string','token','uri','uri-reference','uuid']/>
<#function typeName def>
  <#if !def.global>
    <#local definingInstance=def.definingInstance/>
    <#local parentDef=definingInstance.containingDefinition/>
    <#local name="${typeName(parentDef)}-${def.name}"/>
  <#else>
    <#local name="${def.name}"/>
  </#if>
  <#return name/>
</#function>


<#function typeForDefinition def>
  <#local definitionType="${def.containingMetaschema.shortName}-${typeName(def)}-${def.modelType?upper_case}"/>

  <#-- 
  <#local definitionType="${def.containingMetaschema.shortName}_${def.modelType}_${typeName(def)}_type"/>
  <#local definitionType="${toCamelCase(definitionType)}"/>
   -->
  <#return definitionType/>
</#function>

<#function typeForValue def>
  <#switch def.datatype.name>
    <#case "base64">
      <#local valueType="xs:base64Binary"/>
      <#break>
    <#case "boolean">
      <#local valueType="xs:boolean"/>
      <#break>
    <#case "date">
      <#local valueType="xs:date"/>
      <#break>
    <#case "date-time">
      <#local valueType="xs:dateTime"/>
      <#break>
    <#case "day-time-duration">
      <#-- consider a specialized data type -->
      <#local valueType="xs:duration"/>
      <#break>
    <#case "decimal">
      <#local valueType="xs:decimal"/>
      <#break>
    <#case "integer">
      <#local valueType="xs:integer"/>
      <#break>
    <#case "non-negative-integer">
      <#local valueType="xs:nonNegativeInteger"/>
      <#break>
    <#case "positive-integer">
      <#local valueType="xs:positiveInteger"/>
      <#break>
    <#case "year-month-duration">
      <#-- consider a specialized data type -->
      <#local valueType="xs:duration"/>
      <#break>
    <#default>
      <#if !schemaTypes?seq_contains(def.datatype.name)>
          <#stop "Unsupported data type: ${def.datatype.name}"/>
      </#if>
      
      <#local valueType="${def.datatype.name}"/>
      <@'<#assign ${def.datatype.name}_used=true/>'?replace("-","\\-")?interpret />
  </#switch>

  <#return valueType/>
</#function>

<#macro assemblyDefinition def>
  <xs:complexType<#if !def.inline> name="${typeForDefinition(def)}"</#if>>
    <#if !def.inline>
      <@definitionAnnotation def=def/>
      </#if>
    <#list def.modelInstances>
    <xs:sequence>
      <#items as instance>
          <@modelInstance instance=instance/>
      </#items>
    </xs:sequence>
    </#list>
    <#list def.flagInstances as instance>
        <@flagInstance instance=instance/>
    </#list>
  </xs:complexType>
</#macro>

<#macro fieldDefinition def>
  <#if !def.global && def.flagInstances?size == 0>
    <#-- skip fields without flags, since these are bare simple types -->
    <#return>
  </#if>

  <#local datatype="${typeForValue(def)}"/>
  <#if def.flagInstances?size gt 0 || datatype?string == "markup-line" || datatype?string == "markup-multiline">
    <xs:complexType<#if !def.inline> name="${typeForDefinition(def)}"</#if>>
    <#if !def.inline>
      <@definitionAnnotation def=def/>
    </#if>
    <#if datatype?string == "markup-line" || datatype?string == "markup-multiline">
      <xs:complexContent>
        <xs:extension base="${datatype}"<#rt>
        <#if def.flagInstances?size == 0>
          <#lt>/>
        <#else>
          <#lt>>
          <#list def.flagInstances as instance>
            <@flagInstance instance=instance/>
          </#list>
          </xs:extension>
        </#if>
      </xs:complexContent>
    <#else>
      <xs:simpleContent>
        <xs:extension base="${datatype}"<#rt>
        <#if def.flagInstances?size == 0>
          <#lt>/>
        <#else>
          <#lt>>
          <#list def.flagInstances as instance>
            <@flagInstance instance=instance/>
          </#list>
          </xs:extension>
        </#if>
      </xs:simpleContent>
    </#if>
    </xs:complexType>
  <#else>
    <xs:simpleType<#if !def.inline> name="${typeForDefinition(def)}"</#if>>
    <#if !def.inline>
      <@definitionAnnotation def=def/>
    </#if>
      <xs:restriction base="${datatype}"/>
    </xs:simpleType>
  </#if>
</#macro>

<#macro modelInstance instance>
  <#switch instance.modelType>
    <#case "ASSEMBLY">
    <#case "FIELD">
      <#if (instance.xmlGroupAsBehavior!"UNGROUPED") == "GROUPED">
      <xs:element name="${instance.groupAsName}"<#rt>
        <#if instance.minOccurs == 0>
        <#lt> minOccurs="0"<#rt>
        </#if>
      <#lt>>
        <xs:complexType>
          <xs:sequence>
      </#if>
      <#if instance.modelType == "FIELD" && instance.definition.datatype.name == "markup-multiline" && !instance.inXmlWrapped>
        <xs:sequence minOccurs="${instance.minOccurs}" maxOccurs="unbounded">
          <@definitionAnnotation def=instance.definition/>
          <xs:group ref="blockElementGroup">
          	<@definitionAnnotation def=instance.definition/>
          </xs:group>
        </xs:sequence>
      <#else>
        <xs:element name="${instance.useName}"<#rt>
        <#if (!instance.xmlGroupAsBehavior?? || (instance.xmlGroupAsBehavior!"UNGROUPED") == "UNGROUPED")  && instance.minOccurs != 1>
          <#lt> minOccurs="${instance.minOccurs}"<#rt>
        </#if>
        <#if instance.maxOccurs gt 1>
          <#lt> maxOccurs="${instance.maxOccurs}"<#rt>
        <#elseif instance.maxOccurs == -1>
          <#lt> maxOccurs="unbounded"<#rt>
        </#if>
        <#if instance.definition.global>
          <#lt> type="${typeForDefinition(instance.definition)}"<#rt>
        <#elseif instance.modelType == "FIELD" && instance.definition.flagInstances?size == 0><#-- this is a field without flags -->
          <#lt> type="${typeForValue(instance.definition)}"<#rt>
        </#if>
        <#if instance.definition.inline>
          <#lt>>
            <@definitionAnnotation def=instance.definition/>
            <@definition def=instance.definition/>
          </xs:element>
        <#elseif instance.remarks??>
            <#lt>>
            <xs:annotation>
              <xs:documentation xmlns="http://www.w3.org/1999/xhtml">
                 ${markupToHTML(instance.remarks, "http://csrc.nist.gov/ns/oscal/metaschema/1.0")}
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        <#else>
          <#lt>/>
        </#if>
      </#if>
      <#if (instance.xmlGroupAsBehavior!"UNGROUPED") == "GROUPED">
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      </#if>
        <#break>
    <#case "CHOICE">
      <#list instance.modelInstances>
      <xs:choice>
        <#items as childInstance>
          <@modelInstance instance=childInstance/>
        </#items>
      </xs:choice>
      </#list>
        <#break>
    <#default>
      <#stop "unsupported model type: ${def.modelType}">
  </#switch>
</#macro>

<#macro flagInstance instance>
    <xs:attribute name="${instance.useName}" type="${typeForValue(instance.definition)}"<#rt>
    <#if instance.required>
      <#lt> use="required"<#rt>
    </#if>
    <#lt>>
      <@definitionAnnotation def=instance.definition/>
    </xs:attribute>
</#macro>
<#macro definitionAnnotation def>
  <#if def.formalName?? || def.description??>
    <xs:annotation>
      <xs:appinfo>
  <#if def.formalName??>
        <m:formal-name>${def.formalName}</m:formal-name>
  </#if>
  <#if def.description??>
        <m:description>${markupToHTML(def.description, "http://csrc.nist.gov/ns/oscal/metaschema/1.0")}</m:description>
  </#if>
      </xs:appinfo>
  <#if def.formalName??>
      <xs:documentation xmlns="http://www.w3.org/1999/xhtml">
          <p><b>${def.formalName}</b>: ${markupToHTML(def.description, "http://www.w3.org/1999/xhtml", "")}</p>
      <#if def.remarks??>
         ${markupToHTML(def.remarks, "http://csrc.nist.gov/ns/oscal/metaschema/1.0")}
      </#if>
      </xs:documentation>
  </#if>
    </xs:annotation>
  </#if>
</#macro>
<#macro definition def>
  <#-- Definition: ${typeForDefinition(def)} -->
  <#switch def.modelType>
  <#case "ASSEMBLY">
    <@assemblyDefinition def=def />
    <#break>
  <#case "FIELD">
    <@fieldDefinition def=def />
      <#break>
  </#switch>
</#macro>
<#t>
<#lt><?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:m="http://csrc.nist.gov/ns/oscal/metaschema/1.0"
  xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning"
  targetNamespace="${metaschema.xmlNamespace}"
  xmlns="${metaschema.xmlNamespace}"
  vc:minVersion="1.0" vc:maxVersion="1.1"
  elementFormDefault="qualified"
  version="${metaschema.version}">

  <xs:annotation>
    <xs:appinfo>
      <m:schema-name>${markupToHTML(metaschema.name, "http://csrc.nist.gov/ns/oscal/metaschema/1.0")}</m:schema-name>
      <m:schema-version>${metaschema.version}</m:schema-version>
      <m:short-name>${metaschema.shortName}</m:short-name>
    </xs:appinfo>
    <#if metaschema.remarks??>
       <xs:documentation>
          ${markupToHTML(metaschema.remarks, "http://csrc.nist.gov/ns/oscal/metaschema/1.0")}
      </xs:documentation>
    </#if>
  </xs:annotation>

<#list definitions as def>
  <#if def.global && def.modelType == "ASSEMBLY" && def.root>
  <xs:element name="${def.rootName}" type="${typeForDefinition(def)}"/>
  </#if>
</#list>

<#list definitions?filter(d -> d.global) as def>
  <@definition def=def/>
</#list>

<#if date\-with\-timezone_used?? && date\-with\-timezone_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='date-with-timezone']"].@@markup}
</#noautoesc>
</#if>
<#if dateTime\-with\-timezone_used?? && dateTime\-with\-timezone_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='dateTime-with-timezone']"].@@markup}
</#noautoesc>
</#if>
<#if email_used?? && email_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='email']"].@@markup}
</#noautoesc>
</#if>  
<#if hostname_used?? && hostname_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='hostname']"].@@markup}
</#noautoesc>
</#if>  
<#if ip\-v4\-address_used?? && ip\-v4\-address_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='ip-v4-address']"].@@markup}
</#noautoesc>
</#if>  
<#if ip\-v6\-address_used?? && ip\-v6\-address_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='ip-v6-address']"].@@markup}
</#noautoesc>
</#if>  
<#if string_used?? && string_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='string']"].@@markup}
</#noautoesc>
</#if>
<#if token_used?? && token_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='token']"].@@markup}
</#noautoesc>
</#if>
<#if uri_used?? && uri_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='uri']"].@@markup}
</#noautoesc>
</#if>  
<#if uri\-reference_used?? && uri\-reference_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='uri-reference']"].@@markup}
</#noautoesc>
</#if>  
<#if uuid_used?? && uuid_used == true>
<#noautoesc>
  ${metaschema\-datatypes["xs:schema/xs:simpleType[@name='uuid']"].@@markup}
</#noautoesc>
</#if>  
<#if markup\-multiline_used?? && markup\-multiline_used == true>
<#noautoesc>
  ${metaschema\-prose\-multiline["xs:schema/*[not(local-name()='include')]"].@@markup}
</#noautoesc>
</#if>
<#if markup\-line_used?? && markup\-line_used == true>
<#noautoesc>
  ${metaschema\-prose\-line["xs:schema/*[not(local-name()='include')]"].@@markup}
</#noautoesc>
</#if>
<#if (markup\-line_used?? && markup\-line_used == true) || (markup\-multiline_used?? && markup\-multiline_used == true)>
<#noautoesc>
  ${metaschema\-prose\-base["xs:schema/*"].@@markup}
</#noautoesc>
</#if>
</xs:schema>